##### 1.面向对象有哪些特征，请展开说一说

```
面向对象具有封装、继承、多态三大特征。
封装：从狭义上来说，封装就是把类的属性私有化，再通过公有方法进行访问和修改。
	 从广义上来讲，把一段经常要用到的代码片段定义到方法中或者将多个状态数据
	 定义到类体中。
继承：继承是面向对象最显著的一个特征。继承是从已有的类中派生出新的类，新的类	   能吸收已有类的数据属性和行为，并扩展新的能力。
	 子类不会继承父类的构造方法，只能调用父类里的构造方法，并且一定至少有一	 个子类构造器调用了父类的构造器。
	 父类中私有的属性和方法继承了，但是没有权限访问
	 如何使用父类中的构造器，使用super（有参传参），位置必须在子类构造器中的		首行首句上，因此不能与this（有参传参）共存
多态：多态就是一个对象的多种表现形式或者状态。包括向上造型和向下造型
	 向上造型：
	 	- 父类型的变量引用子类型的对象。   
		- 向上转型肯定会成功，是一个隐式转换。 
		- 向上转型后的对象，将只能够访问父类中的成员（编译期间，看变量）
		- 如果调用的是重写过的方法，那么调用的一定是重写方法（运行期间，看			对象）
		- 应用场景：在定义方法时，形式参数是父类型的变量。这样更加灵活，可			以传任意子类型的对象
	 向下造型：
	 	- 父类型变量赋值给子类型的变量，需要强制转换，是一个显式转换。
		- 可能会失败，失败的话，会报类造型异常ClassCastException
		- 为了避免ClassCastException ,可以使用instanceof 来判断：变量指		  向的对象是否属于某一个类型。
		  子类型   变量名 = (子类型)父类型变量
```

##### 2.this()与super()的区别

this()用于本类构造器中调用其他构造方法。

super()用于子类中构造器调用父类中的构造方法

两者不能共存

##### 3.Overload与Override的区别

Override —重写，是子类对父类的方法进行重新实现

​	子类只能重写父类中存在的方法。

​	重写时，子类中的方法名和参数要与父类保持一致。（区别于重载overload）

​	返回值类型：必须和父类方法的返回值类型相同，或者是其子类型。

​	访问权限：子类重写方法的访问权限必须大于等于父类方法的访问权限。

Overload—重载，是对同一个类中的同名、不同参数方法的描述。

##### 4.构造器是否可以被override?

首先构造器必须与类名相同，其次override的都是从父类继承来的，父类中存在才称作override；最后，虽然子类可以调用父类的构造器（通过 *super()*），但子类不会继承父类的构造器。

##### 5.是否可以继承String类型

不可以。String类是被final修饰词修饰的。final修饰词用在类中表示该类不可被继承。